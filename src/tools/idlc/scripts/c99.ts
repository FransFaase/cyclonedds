/*
 * Copyright(c) 2006 to 2018 ADLINK Technology Limited and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
 * v. 1.0 which is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 */

generate_copyright(file_name,source)
{
  "/*\n"
  " * Copyright(c) 2006 to 2018 ADLINK Technology Limited and others\n"
  " *\n"
  " * This program and the accompanying materials are made available under the\n"
  " * terms of the Eclipse Public License v. 2.0 which is available at\n"
  " * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License\n"
  " * v. 1.0 which is available at\n"
  " * http://www.eclipse.org/org/documents/edl-v10.php.\n"
  " *\n"
  " * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause\n"
  " */\n"
  "/****************************************************************\n"
  "\n"
  "  Generated by Cyclone DDS IDL to C Translator\n"
  "  File name: "; file_name; "\n"
  "  Source: "; source; "\n"
  "  Generated: "; now(); "\n"
  "  Cyclone DDS: V0.1.0\n"
  "\n"
  "*****************************************************************/\n"
  "\n";
}

generate_header_intro(file_name)
{
  "#include \"ddsc/dds_public_impl.h\"\n"
  "\n"
  "#ifndef _DDSL_"; toUpper(file_name); "_H_\n"
  "#define _DDSL_"; toUpper(file_name); "_H_\n"
  "\n"
  "\n"
  "#ifdef __cplusplus\n"
  "extern \"C\" {\n"
  "#endif\n"
  "\n";
}

generate_header_closer(file_name)
{
  "#ifdef __cplusplus\n"
  "}\n"
  "#endif\n"
  "#endif /* _DDSL_$U_H_ */\n"
  with U=toUpper(file_name);
}

name_with_module_prefix(tree)
{
  if (tree.tree_parent) {
    name_with_module_prefix(tree.tree_parent); "_";
  }
  tree.name;
}

generate_forward_struct(tree)
{
  if (!tree.hasProperty("generated")) {
    "typedef struct "; name_with_module_prefix(tree); " "; name_with_module_prefix(tree); ";\n"
    "\n";
    tree.setProperty("generated", true);
  }
}

generate_sequence(tree, declarator, struct_type_name)
{
  "typedef struct $D\n"
  "{\n"
  "  uint32_t _maximum;\n"
  "  uint32_t _length;\n"
  "  $E *_buffer;\n"
  "  bool _release;\n"
  "} $D;\n"
  "\n"
  "#define $D__alloc() \\\n"
  "(($D*) dds_alloc (sizeof ($D)));\n"
  "\n"
  "#define $D_allocbuf(l) \\\n"
  "(($E *) dds_alloc ((l) * sizeof ($E)))\n"
  "\n" with D={name_with_module_prefix(tree); "_"; declarator.name; "_seq";}, E=struct_type_name;
}

generate_header_declaration(type, array_decl, declarator, struct)
{
  if (type.type == "array")
    generate_header_declaration(type.element_type, { array_decl; "["; toStr(type.size); "]"; }, declarator, struct);
  else {
    "  ";
    switch (type.type) {
      case "short_type":              "int16_t "; array_decl;
      case "long_type":               "int32_t "; array_decl;
      case "long_long_type":          "int64_t "; array_decl;
      case "unsigned_short_type":     "uint16_t "; array_decl;
      case "unsigned_long_type":      "uint32_t "; array_decl;
      case "unsigned_long_long_type": "uint64_t "; array_decl;
      case "char_type":               "char "; array_decl;
      case "boolean_type":            "bool "; array_decl;
      case "octet_type":              "uint8_t "; array_decl;
      case "int8_type":               "int8_t "; array_decl;
      case "uint8_type":              "uint8_t "; array_decl;
      case "float_type":              "float "; array_decl;
      case "double_type":             "double "; array_decl;
      case "string":
        if (type.is_bounded) {
          "char "; array_decl; "["; toStr(type.max + 1); "]";
        }
        else {
          "char * "; array_decl;
        }
      case "struct":
          name_with_module_prefix(type); " "; array_decl;
      case "sequence":
          if (   type.element_type.type == "struct"
              || type.element_type.type == "forward_struct"
              || type.element_type.type == "sequence") {
            name_with_module_prefix(struct); "_"; declarator; "_seq "; array_decl;
          }
          else {
           "dds_sequence_t "; array_decl;
          }
      default:
        "// type not supported: "; array_decl;
    }
    ";\n";
  }
}

generate_header_struct(tree)
{
  for child in tree
    switch (child.type) {
      case "struct": generate_header_struct(child);
      case "declaration":
          if (child.decl_type.type == "sequence") {
            if (   child.decl_type.element_type.type == "struct"
                || child.decl_type.element_type.type == "forward_struct") {
              if (child.decl_type.element_type == "struct")
                generate_forward_struct(child.decl_type.element_type);
              generate_sequence(tree, child, name_with_module_prefix(child.decl_type.element_type));
            }
            else if (child.decl_type.element_type.type == "sequence") {
	      generate_sequence(tree, child, "dds_sequence_t");
            }
          }
    }

  "typedef struct $N\n"
  "{\n" with N=name_with_module_prefix(tree);

  for child in tree {
    if (child.type == "declaration") {
      generate_header_declaration(child.decl_type, child.name, child.name, tree);
    }
  }

  "} $N;\n"
  "\n" with N=name_with_module_prefix(tree);

  /*if (tree.part_of)*/ {
    "extern const dds_topic_descriptor_t $N_desc;\n"
    "\n"
    "#define $N__alloc() \\\n"
    "(($N*) dds_alloc (sizeof ($N)));\n"
    "\n"
    "#define $N_free(d,o) \\\n"
    "dds_sample_free ((d), &$N_desc, (o))\n"
    with N=name_with_module_prefix(tree);
  }
}

generate_header_modules(tree)
{
  for child in tree
    switch (child.type) {
      case "module": generate_header_modules(child);
      case "struct": generate_header_struct(child);
      case "forward_struct": generate_forward_struct(child);
    }
}

generate_header_file(type_tree)
{
  generate_copyright({file_name(); ".h";}, file_name());
  generate_header_intro(file_name());
  generate_header_modules(type_tree);
  generate_header_closer(file_name());
}

generate_op_codes_simple(op_type, struct, path)
{
  "  DDS_OP_ADR | DDS_OP_TYPE_$O, offsetof($S, $P),\n"
  with O=op_type, S=struct.name, P=path;
}

generate_op_codes_decl(struct, struct_member, decl, path)
{
  switch (struct_member.decl_type.type) {
    case "short_type":              generate_op_codes_simple("2BY", struct, path);
    case "long_type":               generate_op_codes_simple("4BY", struct, path);
    case "long_long_type":          generate_op_codes_simple("8BY", struct, path);
    case "unsigned_short_type":     generate_op_codes_simple("2BY", struct, path);
    case "unsigned_long_type":      generate_op_codes_simple("4BY", struct, path);
    case "unsigned_long_long_type": generate_op_codes_simple("8BY", struct, path);
    case "char_type":               generate_op_codes_simple("1BY", struct, path);
    case "boolean_type":            generate_op_codes_simple("1BY", struct, path);
    case "octet_type":              generate_op_codes_simple("1BY", struct, path);
    case "int8_type":               generate_op_codes_simple("1BY", struct, path);
    case "uint8_type":              generate_op_codes_simple("1BY", struct, path);
    case "float_type":              generate_op_codes_simple("4BY", struct, path);
    case "double_type":             generate_op_codes_simple("8BY", struct, path);
    case "string":
      /* FIXME: */
    case "struct":
      for child in struct_member.decl_type {
	if (child.type == "declarator") {
          for decl in child {
            generate_op_codes_decl(struct, child, decl, { path; "."; decl.name; });
          }
        }
      }
    case "array":
      /* FIXME: */
    case "sequence":
      /* FIXME: */
    default:
  }
}

generate_op_codes_struct(struct)
{
  for child in struct {
    if (child.type == "struct_member") {
      for decl in child {
        generate_op_codes_decl(struct, child, decl, decl.name);
      }
    }
  }
  "  DDS_TS_OP_RTS";
}


generate_meta_data_type(type)
{
  switch (type.type) {
    case "short_type":              "<Short/>";
    case "long_type":               "<Long/>";
    case "long_long_type":          "<LongLong/>";
    case "unsigned_short_type":     "<UShort/>";
    case "unsigned_long_type":      "<ULong/>";
    case "unsigned_long_long_type": "<ULongLong/>";
    case "char_type":               "<Char/>";
    case "boolean_type":            "<Boolean/>";
    case "octet_type":              "<Octet/>";
    case "int8_type":               "<Int8/>";
    case "uint8_type":              "<UInt8/>";
    case "float_type":              "<Float/>";
    case "double_type":             "<Double/>";
    case "string_type":
      if (type.bounded)
        "<Sting length=\\\"$N\\\"/>" with N=toStr(type.max);
      else
        "<String/>";
    case "sequence":
      "<Sequence>";
      generate_meta_data_type(type.element_type);
      "</Sequence>";
    case "array":
      "<Array size=\\\"$N\\\"/>" with N=toStr(type.size);
      generate_meta_data_type(type.element_type);
      "</Array>";
    case "struct":
      if (type.tree_parent && type.tree_parent.type == "struct")
        generate_meta_data_struct(type);
      else
        "<Type name=\\\"$N\\\"/>" with N=type.name;
  }
}

generate_meta_data_struct(struct)
{
  "<Struct name=\\\"$N\\\">" with N=struct.name;
  for member in struct
    if (member.type == "declaration") {
      "<Member name=\\\"$N\\\">" with N=member.name;
      generate_meta_data_type(member.decl_type);
      "</Member>";
    }
  "</Struct>";
}

generate_meta_data_module(module)
{
  for child in module
    if (child.getProperty("used")) {
      switch(child.type) {
        case "module":
          "<Module name=\\\"$N\\\">" with N=child.name;
          generate_meta_data_module(child);
          "</Module>";
        case "struct":
          generate_meta_data_struct(child);
      }
    }
}

mark_used_module(module)
{
  if (!module.getProperty("used")) {
    module.setProperty("used", true);
    if (module.tree_parent)
      mark_used_module(module.tree_parent);
  }
}

mark_used_struct(struct)
{
  if (!struct.getProperty("used")) {
    struct.setProperty("used", true);
    if (struct.tree_parent)
      mark_used_module(struct.tree_parent);
    for member in struct
      switch (member.type) {
        case "struct":
          mark_used_struct(member);
        case "sequence":
          mark_used_type_spec(member.element_type);
      }
  }
}

mark_used_type_spec(type_spec)
{
  switch(type_spec.type) {
    case "sequence":
      mark_used_type_spec(type_spec.element_type);
    case "struct":
      mark_used_struct(type_spec);
    case "forward_struct":
      if (type_spec.definition)
        mark_used_struct(type_spec.definition);
  }
}

generate_meta_data(struct)
{
  mark_used_struct(struct);
  generate_meta_data_module(root());
  root().removeProperties("used");
}


generate_source_struct(struct)
{
  "\n\n"
  "static const dds_key_descriptor_t $N_keys[0] =\n"
  "{\n"
  "};\n"
  "\n"
  "static const uint32_t $N_ops [] =\n"
  "{\n"
  with N=name_with_module_prefix(struct);
  generate_op_codes_struct(struct);
  "\n};\n"
  "\n"
  "const dds_topic_descriptor_t $N_desc =\n"
  "{\n"
  "  sizeof ($N),\n"
  "  8u,\n"
  "  DDS_TOPIC_FIXED_KEY | DDS_TOPIC_NO_OPTIMIZE,\n"
  "  3u,\n"
  "  \"\",\n"
  "  $N_keys,\n"
  "  45,\n"
  "  $N_ops,\n"
  "  \""
  with N=name_with_module_prefix(struct);
  generate_meta_data(struct);
  "\"\n"
  "};\n";
}

generate_source_modules(tree)
{
  for child in tree
    switch (child.type) {
      case "module": generate_source_modules(child);
      case "struct":
        /*if (!child.part_of)*/
          generate_source_struct(child);
    }
}

generate_source_file(type_tree)
{
  generate_copyright({file_name(); ".c";}, file_name());
  generate_header_intro(file_name());
  generate_source_modules(type_tree);
  generate_header_closer(file_name());
}

main(type_tree)
{
  streamToFile({file_name(); ".h";}, generate_header_file(type_tree));
  streamToFile({file_name(); ".c";}, generate_source_file(type_tree));
}
