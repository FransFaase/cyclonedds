/*
 * Copyright(c) 2006 to 2018 ADLINK Technology Limited and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
 * v. 1.0 which is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 */
%{
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

/* yyscan_t is an opaque pointer, a typedef is required here to break a
   circular dependency introduced with bison 2.6 (normally a typedef is
   generated by flex). the define is required to disable the typedef in flex
   generated code */
#define YY_TYPEDEF_YY_SCANNER_T

typedef void *yyscan_t;

//#include "os/os_stdlib.h"

#include "idl.parser.h"
#include "yy_decl.h" /* prevent implicit declaration of yylex */

int
yyerror(
  YYLTYPE *yylloc, yyscan_t yyscanner, idl_context_t *context, char *text);

static int
idl_parser_token_matches_keyword(const char *token);
%}


%code requires {

#include <stdbool.h>
/* FIXME: */
#include "type.h"

struct idl_context {
  /* FIXME: implement */
  int ignore_yyerror;
};

typedef struct idl_context idl_context_t;
}


%union {
  bool boolean;
  idl_basic_type_t type;
  idl_literal_t literal;
  idl_identifier_t identifier;
  //idl_scoped_name_t* scoped_name;
}

%define api.pure full
%define api.prefix {idl_parser_}
%define parse.trace

%locations
%param {yyscan_t scanner}
%param {idl_context_t *context}

%token-table

%start specification 

%token <identifier>
  IDENTIFIER

%token <boolean>
  BOOLEAN_LITERAL

%token <literal>
  CHARACTER_LITERAL
  WIDE_CHARACTER_LITERAL
  STRING_LITERAL
  WIDE_STRING_LITERAL
  INTEGER_LITERAL
  FLOATING_PT_LITERAL
  FIXED_PT_LITERAL

%type <type>
  simple_type_spec
  base_type_spec
  const_type
  floating_pt_type
  fixed_pt_const_type
  integer_type
  signed_int
  signed_tiny_int
  signed_short_int
  signed_long_int
  signed_longlong_int
  unsigned_int
  unsigned_tiny_int
  unsigned_short_int
  unsigned_long_int
  unsigned_longlong_int
  char_type
  wide_char_type
  boolean_type
  octet_type
/*any_type*/

%type <literal>
  literal
  const_expr
  primary_expr

%type <identifier> identifier

/* operators */
%token LSHIFT RSHIFT

/* keywords */
%token MODULE "module"
%token CONST "const"
%token NATIVE "native"
%token STRUCT "struct"
%token TYPEDEF "typedef"
%token UNION "union"
%token SWITCH "switch"
%token CASE "case"
%token ENUM "enum"
%token UNSIGNED "unsigned"
%token FIXED "fixed"
%token SEQUENCE "sequence"
%token STRING "string"

%token FLOAT "float"
%token DOUBLE "double"
%token SHORT "short"
%token LONG "long"
%token CHAR "char"
%token WCHAR "wchar"
%token BOOLEAN "boolean"
%token OCTET "octet"
%token ANY "any"

%token MAP "map"
%token BITSET "bitset"
%token BITFIELD "bitfield"
%token BITMASK "bitmask"

%token INT8 "int8"
%token UINT8 "uint8"
%token INT16 "int16"
%token INT32 "int32"
%token INT64 "int64"
%token UINT16 "uint16"
%token UINT32 "uint32"
%token UINT64 "uint64"

%token DEFAULT "default"
%token ANNOTATION "@annotation"


%%


/* Constant Declaration */

specification:
    definitions
  ;

definitions:
    definition definitions
  | definition
  ;

definition:
    module_dcl ';'
  | const_dcl ';'
  | type_dcl ';'
  | pragma_keylist
  ;

module_dcl:
    annotation_appls MODULE identifier '{' definitions '}'
       { };

scoped_name:
     identifier
       { /*$$ = idl_new_scoped_name(0, false, $1);*/ }
   | "::" identifier
       { /*$$ = idl_new_scoped_name(0, true, $2);*/ }
   | scoped_name "::" identifier
       { /*$$ = idl_new_scoped_name($1, false, $3);*/ } 
   ;

const_dcl:
    annotation_appls CONST const_type identifier '=' const_expr
      { /* FIXME: printf("const_type is of: %d\n", ($2)->basic_type); */ }
  ;

const_type:
    integer_type
  | floating_pt_type
  | fixed_pt_const_type
  | char_type
  | wide_char_type
  | boolean_type
  | octet_type
/* FIXME: string_type */
/* FIXME: wide_string_type */
  | scoped_name { /*$$ = new_idl_type_from_scoped_name($1);*/ }
  ;

const_expr:
    or_expr
      { };

or_expr:
    xor_expr
  | or_expr '|' xor_expr
      { };

xor_expr:
    and_expr
  | xor_expr '^' and_expr
      { };

and_expr:
    shift_expr
  | and_expr '&' shift_expr
      { };

shift_expr:
    add_expr
  | shift_expr "<<" add_expr
      { }
  | shift_expr ">>" add_expr
      { };

add_expr:
    mult_expr
  | add_expr '+' mult_expr
      { }
  | add_expr '-' mult_expr
      { };

mult_expr:
    unary_expr
  | mult_expr '*' unary_expr
      { }
  | mult_expr '/' unary_expr
      { }
  | mult_expr '%' unary_expr
      { };

unary_expr:
    unary_operator primary_expr
  | primary_expr;

unary_operator:
    '-' { }
  | '+' { }
  | '~' { };

primary_expr:
/* FIXME:    scoped_name
  |*/
    literal
      {
        /*idl_literal_t *lit = &($$);
        printf("literal is of type: %d\n", lit->type);*/
      }
  | '(' const_expr ')'
      { $$ = $2; };

literal:
    INTEGER_LITERAL
  | FLOATING_PT_LITERAL
  | FIXED_PT_LITERAL
  | CHARACTER_LITERAL
/* FIXME: WIDE_CHARACTER_LITERAL */
  | BOOLEAN_LITERAL
      {
        /*idl_literal_t* literal = &($$);
        literal->type = idl_boolean_literal;
        literal->value.bln = ($1);
        literal->scoped_name = 0;*/
      }
  | STRING_LITERAL
/* FIXME: WIDE_STRING_LITERAL */
  ;

positive_int_const:
    const_expr;

type_dcl:
    constr_type_dcl
  | native_dcl
  | typedef_dcl
  ;

type_spec:
    simple_type_spec ;

simple_type_spec:
    base_type_spec
  | scoped_name { /*$$ = new_idl_type_from_scoped_name($1);*/ }
  ;

base_type_spec:
    integer_type
  | floating_pt_type
  | char_type
  | wide_char_type
  | boolean_type
  | octet_type
  ;

/* Basic Types */
floating_pt_type:
    FLOAT { /*$$ = new_idl_type_from_basic_type(idl_float);*/ }
  | DOUBLE { /*$$ = new_idl_type_from_basic_type(idl_double);*/ }
  | LONG DOUBLE { /*$$ = new_idl_type_from_basic_type(idl_longdouble);*/ };

integer_type:
    signed_int
  | unsigned_int
  ;

signed_int:
    SHORT { /*$$ = new_idl_type_from_basic_type(idl_short);*/ }
  | LONG { /*$$ = new_idl_type_from_basic_type(idl_long);*/ }
  | LONG LONG { /*$$ = new_idl_type_from_basic_type(idl_longlong);*/ }
  ;

unsigned_int:
    UNSIGNED SHORT { /*$$ = new_idl_type_from_basic_type(idl_ushort);*/ }
  | UNSIGNED LONG { /*$$ = new_idl_type_from_basic_type(idl_ulong);*/ }
  | UNSIGNED LONG LONG { /*$$ = new_idl_type_from_basic_type(idl_ulonglong);*/ }
  ;

char_type:
    CHAR { /*$$ = new_idl_type_from_basic_type(idl_char);*/ };

wide_char_type:
    WCHAR { /*$$ = new_idl_type_from_basic_type(idl_wchar);*/ };

boolean_type:
    BOOLEAN { /*$$ = new_idl_type_from_basic_type(idl_boolean);*/ };

octet_type:
    OCTET { /*$$ = new_idl_type_from_basic_type(idl_octet);*/ };

/*any_type:
    ANY { $$ = idl_any; };*/

template_type_spec:
    sequence_type
  | string_type
/* FIXME:  | wide_string_type */
  | fixed_pt_type
  ;

sequence_type:
    SEQUENCE '<' type_spec ',' positive_int_const '>'
  | SEQUENCE '<' type_spec '>'
  ;

string_type:
    STRING '<' positive_int_const '>'
  | STRING 
  ;

/* FIXME:
wide_string_type:
    WSTRING '<' positive_int_const '>'
  | WSTRING 
  ;
*/

fixed_pt_type:
    FIXED '<' positive_int_const ',' positive_int_const '>'
  ;

fixed_pt_const_type: FIXED { /*$$ = idl_fixed;*/ };

constr_type_dcl:
    struct_dcl
  | union_dcl
  | enum_dcl
  ;

struct_dcl:
    struct_def
  | struct_forward_dcl
  ;

struct_def:
    annotation_appls STRUCT identifier '{' members '}'
  ;
members:
    member members
  | member
  ;

member:
    annotation_appls type_spec declarators ';'
  ;

struct_forward_dcl: 
    annotation_appls STRUCT identifier ;

union_dcl:
    union_def
  | union_forward_dcl
  ;

union_def:
    annotation_appls UNION identifier SWITCH '(' switch_type_spec ')'
    '{' switch_body '}'
  ;
switch_type_spec:
    integer_type
  | char_type
  | boolean_type
  | scoped_name
  ;

switch_body: cases ;
cases:
    case cases
  | case
  ;

case:
    case_labels element_spec ';'
  ;

case_labels:
    case_label case_labels
  | case_label
  ;

case_label:
    CASE const_expr ':'
  | DEFAULT ':'
  ;

element_spec:
    type_spec declarator 
  ;

union_forward_dcl:
    annotation_appls UNION identifier
  ;

enum_dcl:
    annotation_appls ENUM identifier
    '{' enumerator_list '}'
  ;

enumerator_list:
    enumerator ',' enumerator_list
  | enumerator
  ;

enumerator: identifier ;

array_declarator:
    identifier fixed_array_sizes
  ;

fixed_array_sizes:
    fixed_array_size fixed_array_sizes
  | fixed_array_size
  ;

fixed_array_size:
    '[' positive_int_const ']'
  ;

native_dcl:
    annotation_appls NATIVE simple_declarator
  ;

simple_declarator: identifier ;

typedef_dcl:
    annotation_appls TYPEDEF type_declarator
  ;

type_declarator:
    simple_type_spec any_declarators
  | template_type_spec any_declarators
  | constr_type_dcl any_declarators
  ;

any_declarators:
    any_declarator ',' any_declarators
  | any_declarator
  ;

any_declarator:
    simple_declarator
  | array_declarator
  ;

declarators:
    declarator ',' declarators
  | declarator
  ;

declarator: simple_declarator


// From Building Block Extended Data-Types:
struct_def:
    annotation_appls STRUCT identifier ':' scoped_name '{' members '}'
  | annotation_appls STRUCT identifier '{' '}'
  ;

switch_type_spec: 
    wide_char_type
  | octet_type
  ;

template_type_spec:
     map_type
  ;

constr_type_dcl:
     bitset_dcl
   | bitmask_dcl
   ;

map_type:
    annotation_appls MAP '<' type_spec ',' type_spec ',' positive_int_const '>'
  | annotation_appls MAP '<' type_spec ',' type_spec '>'
  ;

bitset_dcl:
    BITSET identifier scoped_name_opt '{' bitfields '}'
  ;

scoped_name_opt:
    ':' scoped_name_opt
  |
  ;

bitfields:
    bitfield bitfields
  | bitfield
  ;

bitfield:
    bitfield_spec identifiers ';'
  ;

identifiers:
    identifier identifiers
  | identifier
  ;

bitfield_spec:
    BITFIELD '<' positive_int_const '>'
  | BITFIELD '<' positive_int_const ',' destination_type '>'
  ;

destination_type:
    boolean_type 
  | octet_type 
  | integer_type
  ;

bitmask_dcl:
    BITMASK identifier '{' bit_value_list '}'
  ;

bit_value_list:
    bit_value ',' bit_value_list
  | bit_value
  ;

bit_value: identifier ;

signed_int: 
    signed_tiny_int 
  | signed_short_int
  | signed_long_int
  | signed_longlong_int
  ;

unsigned_int:
    unsigned_tiny_int
  | unsigned_short_int
  | unsigned_long_int
  | unsigned_longlong_int
  ;

signed_tiny_int: INT8 { /*$$ = new_idl_type_from_basic_type(idl_short); FIXME: */};
unsigned_tiny_int: UINT8 { /*$$ = new_idl_type_from_basic_type(idl_ushort); FIXME: */};
signed_short_int: INT16 { /*$$ = new_idl_type_from_basic_type(idl_short);*/ };
signed_long_int: INT32 { /*$$ = new_idl_type_from_basic_type(idl_long);*/ };
signed_longlong_int: INT64 { /*$$ = new_idl_type_from_basic_type(idl_longlong);*/ };
unsigned_short_int: UINT16 { /*$$ = new_idl_type_from_basic_type(idl_ushort);*/ };
unsigned_long_int: UINT32 { /*$$ = new_idl_type_from_basic_type(idl_ulong);*/ };
unsigned_longlong_int: UINT64 { /*$$ = new_idl_type_from_basic_type(idl_ulonglong);*/ };

// From Building Block Anonymous Types:
type_spec: template_type_spec ;
declarator: array_declarator ;

// From Building Block Annotations:
definition: annotation_dcl ';' ;

annotation_dcl:
    annotation_header '{' annotation_bodys '}'
  ;
annotation_header:
     ANNOTATION identifier
  ;

annotation_bodys:
    annotation_body annotation_bodys
  |
  ;

annotation_body:
    annotation_member
  | enum_dcl ';'
  | const_dcl ';'
  | typedef_dcl ';'
  ;

annotation_member:
    annotation_member_type simple_declarator default_opt ';'
  ;
default_opt:
    DEFAULT const_expr ';'
  |
  ;

annotation_member_type:
    const_type 
  | any_const_type 
/*  | scoped_name -- included in const_type */ 
  ;

any_const_type: ANY ;

annotation_appls:
    annotation_appl annotation_appls
  |
  ;

annotation_appl: 
    '@' scoped_name annotation_appl_params_opt
  ;
annotation_appl_params_opt:
    '(' annotation_appl_params ')'
  |
  ;

annotation_appl_params:
    const_expr
  | annotation_appl_param_list
  ;

annotation_appl_param_list:
    annotation_appl_param ',' annotation_appl_param_list
  | annotation_appl_param
  ;

annotation_appl_param:
    identifier '=' const_expr
  ;

identifier:
    IDENTIFIER
      {
        size_t offset = 0;
        if ($1[0] == '_') {
          offset = 1;
        } else if (idl_parser_token_matches_keyword($1) != 0) {
          /* FIXME: come up with a better error message */
          yyerror(&yylloc, scanner, context, "Identifier matches a keyword");
          fprintf(stderr, "'%s'\n", $1);
          YYABORT;
        } else if (($$ = strdup($1 + offset)) == NULL) {
          /* FIXME: come up with a better error message */
          yyerror(&yylloc, scanner, context, "Memory exhausted");
          YYABORT;
        }
      };

/* Backward compatability #pragma keylist */

pragma_keylist:
    "#pragma" "keylist" identifier keylist_members ;
keylist_members:
    identifier keylist_members
  |
  ;

%%

int
yyerror(
  YYLTYPE *yylloc, yyscan_t yyscanner, idl_context_t *context, char *text)
{
  /* FIXME: implement */
  if (context != 0 && context->ignore_yyerror != 0) {
    return 0;
  }

  fprintf(stderr, "ERROR: %s\n", text);
  return 0;
}

static int
idl_parser_token_matches_keyword(const char *token)
{
  size_t i, n;

  assert(token != NULL);

  for (i = 0, n = strlen(token); i < YYNTOKENS; i++) {
    if (yytname[i] != 0
        && yytname[i][    0] == '"'
        //&& os_strncasecmp_c(yytname[i] + 1, token, n) == 0
        && strncmp(yytname[i]+1, token, n) == 0
        && yytname[i][n + 1] == '"'
        && yytname[i][n + 2] == 0)
    {
      return 1;
    }
  }

  return 0;
}

