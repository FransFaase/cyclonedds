/*
 * Copyright(c) 2006 to 2018 ADLINK Technology Limited and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
 * v. 1.0 which is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 */
%{
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

/* yyscan_t is an opaque pointer, a typedef is required here to break a
   circular dependency introduced with bison 2.6 (normally a typedef is
   generated by flex). the define is required to disable the typedef in flex
   generated code */
#define YY_TYPEDEF_YY_SCANNER_T

typedef void *yyscan_t;

//#include "os/os_stdlib.h"

#include "idl.parser.h"
#include "yy_decl.h" /* prevent implicit declaration of yylex */

#define YYFPRINTF (unsigned int)fprintf

int
yyerror(
  YYLTYPE *yylloc, yyscan_t yyscanner, idl_context_t *context, char *text);

static int
idl_parser_token_matches_keyword(const char *token);
%}


%code requires {

#include <stdbool.h>
/* FIXME: */
#include "type.h"

}


%union {
  bool boolean;
  idl_basic_type_t basic_type;
  idl_type_t *type;
  idl_bit_value_list_t *bit_value_list;
  idl_literal_t literal;
  idl_identifier_t identifier;
  idl_operator_type_t operator_type;
  idl_scoped_name_t* scoped_name;
}

%define api.pure full
%define api.prefix {idl_parser_}
%define parse.trace

%locations
%param {yyscan_t scanner}
%param {idl_context_t *context}

%token-table

%start specification 

%token <identifier>
  IDENTIFIER

%token <boolean>
  BOOLEAN_LITERAL

%token <literal>
  CHARACTER_LITERAL
  WIDE_CHARACTER_LITERAL
  STRING_LITERAL
  WIDE_STRING_LITERAL
  INTEGER_LITERAL
  FLOATING_PT_LITERAL
  FIXED_PT_LITERAL

%type <basic_type>
  simple_type_spec
  switch_type_spec
  base_type_spec
  destination_type
  annotation_member_type
  const_type
  floating_pt_type
  fixed_pt_const_type
  integer_type
  signed_int
  signed_tiny_int
  signed_short_int
  signed_long_int
  signed_longlong_int
  unsigned_int
  unsigned_tiny_int
  unsigned_short_int
  unsigned_long_int
  unsigned_longlong_int
  char_type
  wide_char_type
  boolean_type
  octet_type
  any_const_type

%type <type>
  type_spec
  template_type_spec
  sequence_type
  string_type
  fixed_pt_type
  map_type
  scoped_name_opt

%type <scoped_name>
  scoped_name

%type <bit_value_list>
  bit_value_list

%type <literal>
  positive_int_const
  literal
  const_expr
  or_expr
  xor_expr
  and_expr
  shift_expr
  add_expr
  mult_expr
  unary_expr
  primary_expr

%type <operator_type> unary_operator

%type <identifier>
  simple_declarator
  bit_value
  identifier

/* operators */
%token LSHIFT "<<"
%token RSHIFT ">>"

/* keywords */
%token MODULE "module"
%token CONST "const"
%token NATIVE "native"
%token STRUCT "struct"
%token TYPEDEF "typedef"
%token UNION "union"
%token SWITCH "switch"
%token CASE "case"
%token ENUM "enum"
%token UNSIGNED "unsigned"
%token FIXED "fixed"
%token SEQUENCE "sequence"
%token STRING "string"

%token FLOAT "float"
%token DOUBLE "double"
%token SHORT "short"
%token LONG "long"
%token CHAR "char"
%token WCHAR "wchar"
%token BOOLEAN "boolean"
%token OCTET "octet"
%token ANY "any"

%token MAP "map"
%token BITSET "bitset"
%token BITFIELD "bitfield"
%token BITMASK "bitmask"

%token INT8 "int8"
%token UINT8 "uint8"
%token INT16 "int16"
%token INT32 "int32"
%token INT64 "int64"
%token UINT16 "uint16"
%token UINT32 "uint32"
%token UINT64 "uint64"

%token DEFAULT "default"
%token ANNOTATION "@annotation"


%%


/* Constant Declaration */

specification:
    definitions
  ;

definitions:
    definition definitions
  | definition
  ;

definition:
    module_dcl ';'
  | const_dcl ';'
  | type_dcl ';'
  | pragma_keylist
  ;

module_dcl:
    annotation_appls MODULE identifier { idl_add_module_open(context, $3); }
    '{' definitions '}'
       { idl_module_close(context); };

scoped_name:
     identifier
       { $$ = idl_new_scoped_name(context, 0, false, $1); }
   | "::" identifier
       { $$ = idl_new_scoped_name(context, 0, true, $2); }
   | scoped_name "::" identifier
       { $$ = idl_new_scoped_name(context, $1, false, $3); } 
   ;

const_dcl:
    annotation_appls CONST const_type identifier '=' const_expr
      { /* FIXME: printf("const_type is of: %d\n", ($2)->basic_type); */
        idl_print_literal(stderr, $6); fprintf(stderr, "\n");
      }
  ;

const_type:
    integer_type
  | floating_pt_type
  | fixed_pt_const_type
  | char_type
  | wide_char_type
  | boolean_type
  | octet_type
/* FIXME: string_type */
/* FIXME: wide_string_type */
  | scoped_name { /*$$ = new_idl_type_from_scoped_name($1);*/ }
  ;

const_expr:
    or_expr ;

or_expr:
    xor_expr
  | or_expr '|' xor_expr
      { idl_eval_binary_oper(idl_operator_or, $1, $3, &($$)); };

xor_expr:
    and_expr
  | xor_expr '^' and_expr
      { idl_eval_binary_oper(idl_operator_xor, $1, $3, &($$)); };

and_expr:
    shift_expr
  | and_expr '&' shift_expr
      { idl_eval_binary_oper(idl_operator_and, $1, $3, &($$)); };

shift_expr:
    add_expr
  | shift_expr "<<" add_expr
      { idl_eval_binary_oper(idl_operator_shift_left, $1, $3, &($$)); }
  | shift_expr ">>" add_expr
      { idl_eval_binary_oper(idl_operator_shift_right, $1, $3, &($$)); };

add_expr:
    mult_expr
  | add_expr '+' mult_expr
      { idl_eval_binary_oper(idl_operator_add, $1, $3, &($$)); }
  | add_expr '-' mult_expr
      { idl_eval_binary_oper(idl_operator_sub, $1, $3, &($$)); };

mult_expr:
    unary_expr
  | mult_expr '*' unary_expr
      { idl_eval_binary_oper(idl_operator_times, $1, $3, &($$)); }
  | mult_expr '/' unary_expr
      { idl_eval_binary_oper(idl_operator_div, $1, $3, &($$)); }
  | mult_expr '%' unary_expr
      { idl_eval_binary_oper(idl_operator_mod, $1, $3, &($$)); };

unary_expr:
    unary_operator primary_expr { idl_eval_unary_oper($1, $2, &($$)); }
  | primary_expr;

unary_operator:
    '-' { $$ = idl_operator_minus; }
  | '+' { $$ = idl_operator_plus; }
  | '~' { $$ = idl_operator_inv; };

primary_expr:
/* FIXME:    scoped_name
  |*/
    literal
      {
        /*idl_literal_t *lit = &($$);
        printf("literal is of type: %d\n", lit->type);*/
      }
  | '(' const_expr ')'
      { $$ = $2; };

literal:
    INTEGER_LITERAL
  | FLOATING_PT_LITERAL
  | FIXED_PT_LITERAL
  | CHARACTER_LITERAL
/* FIXME: WIDE_CHARACTER_LITERAL */
  | BOOLEAN_LITERAL
      {
        /*idl_literal_t* literal = &($$);
        literal->type = idl_boolean_literal;
        literal->value.bln = ($1);
        literal->scoped_name = 0;*/
      }
  | STRING_LITERAL
/* FIXME: WIDE_STRING_LITERAL */
  ;

positive_int_const:
    const_expr;

type_dcl:
    constr_type_dcl
  | native_dcl
  | typedef_dcl
  ;

type_spec:
    simple_type_spec { $$ = idl_new_basic_type(context, $1); };

simple_type_spec:
    base_type_spec 
  | scoped_name { /*$$ = idl_get_type_from_scoped_name($1);*/ }
  ;

base_type_spec:
    integer_type
  | floating_pt_type
  | char_type
  | wide_char_type
  | boolean_type
  | octet_type
  ;

/* Basic Types */
floating_pt_type:
    FLOAT { $$ = idl_float; }
  | DOUBLE { $$ = idl_double; }
  | LONG DOUBLE { $$ = idl_longdouble; };

integer_type:
    signed_int
  | unsigned_int
  ;

signed_int:
    SHORT { $$ = idl_short; }
  | LONG { $$ = idl_long; }
  | LONG LONG { $$ = idl_longlong; }
  ;

unsigned_int:
    UNSIGNED SHORT { $$ = idl_ushort; }
  | UNSIGNED LONG { $$ = idl_ulong; }
  | UNSIGNED LONG LONG { $$ = idl_ulonglong; }
  ;

char_type:
    CHAR { $$ = idl_char; };

wide_char_type:
    WCHAR { $$ = idl_wchar; };

boolean_type:
    BOOLEAN { $$ = idl_boolean; };

octet_type:
    OCTET { $$ = idl_octet; };

template_type_spec:
    sequence_type
  | string_type
/* FIXME:  | wide_string_type */
  | fixed_pt_type
  ;

sequence_type:
    SEQUENCE '<' type_spec ',' positive_int_const '>'
      { $$ = idl_new_sequence_type(context, $3, $5); }
  | SEQUENCE '<' type_spec '>'
      { $$ = idl_new_sequence_type_unbound(context, $3); }
  ;

string_type:
    STRING '<' positive_int_const '>'
      { $$ = idl_new_string_type(context, $3); }
  | STRING
      { $$ = idl_new_string_type_unbound(context); }
  ;

/* FIXME:
wide_string_type:
    WSTRING '<' positive_int_const '>'
  | WSTRING 
  ;
*/

fixed_pt_type:
    FIXED '<' positive_int_const ',' positive_int_const '>'
      { $$ = idl_new_fixed_type(context, $3, $5); }
  ;

fixed_pt_const_type: FIXED { /*$$ = idl_fixed;*/ };

constr_type_dcl:
    struct_dcl
  | union_dcl
  | enum_dcl
  ;

struct_dcl:
    struct_def
  | struct_forward_dcl
  ;

struct_def:
    annotation_appls STRUCT identifier '{'
      { idl_add_struct_open(context, $3); }
    members '}' 
      { idl_struct_close(context); }
  ;
members:
    member members
  | member
  ;

member:
    annotation_appls type_spec { idl_add_struct_member(context, $2); } 
    declarators ';'
  ;

struct_forward_dcl: 
    annotation_appls STRUCT identifier 
      { idl_add_struct_forward(context, $3); };

union_dcl:
    union_def
  | union_forward_dcl
  ;

union_def:
    annotation_appls UNION identifier SWITCH '(' switch_type_spec ')'
       { idl_add_union_open(context, $3, $6); }
    '{' switch_body '}'
       { idl_union_close(context); }
  ;
switch_type_spec:
    integer_type
  | char_type
  | boolean_type
  | scoped_name { $$ = idl_get_basic_type_of_scoped_name(context, $1); }
  ;

switch_body: cases ;
cases:
    case cases
  | case
  ;

case:
    case_labels element_spec ';'
  ;

case_labels:
    case_label case_labels
  | case_label
  ;

case_label:
    CASE const_expr ':' { idl_add_union_case_label(context, $2); }
  | DEFAULT ':' { idl_add_union_case_default(context); }
  ;

element_spec:
    type_spec { idl_add_union_element(context, $1); }
    declarator 
  ;

union_forward_dcl:
    annotation_appls UNION identifier { idl_add_union_forward(context, $3); }
  ;


enum_dcl:
    annotation_appls ENUM identifier { idl_add_enum_open(context, $3); }
    '{' enumerator_list '}' { idl_enum_close(context); }
  ;

enumerator_list:
    enumerator ',' enumerator_list
  | enumerator
  ;

enumerator: identifier { idl_add_enum_enumerator(context, $1); };

array_declarator:
    identifier 
    fixed_array_sizes { idl_add_declarator(context, $1); }
  ;

fixed_array_sizes:
    fixed_array_size fixed_array_sizes
  | fixed_array_size
  ;

fixed_array_size:
    '[' positive_int_const ']' { idl_add_array_size(context, $2); }
  ;

native_dcl:
    annotation_appls NATIVE simple_declarator
      { idl_add_native(context, $3); }
  ;

simple_declarator: identifier ;

typedef_dcl:
    annotation_appls TYPEDEF { idl_add_typedef_open(context); }
    type_declarator
  ;

type_declarator:
    simple_type_spec
      { idl_typedef_set_type(context, idl_new_basic_type(context, $1)); }
    any_declarators
      { idl_typedef_close(context); }
  | template_type_spec
      { idl_typedef_set_type(context, $1); }
    any_declarators
      { idl_typedef_close(context); }
  | constr_type_dcl any_declarators
      { idl_typedef_close(context); }
  ;

any_declarators:
    any_declarator ',' any_declarators
  | any_declarator
  ;

any_declarator:
    simple_declarator
  | array_declarator
  ;

declarators:
    declarator ',' declarators
  | declarator
  ;

declarator: simple_declarator
      { idl_add_declarator(context, $1); };


// From Building Block Extended Data-Types:
struct_def:
    annotation_appls STRUCT identifier ':' scoped_name '{' 
      { idl_add_struct_extension_open(context, $3, $5); }
    members '}'
      { idl_struct_close(context); }
  | annotation_appls STRUCT identifier '{'
      { idl_add_struct_open(context, $3); }
    '}'
      { idl_struct_empty_close(context); }
  ;

switch_type_spec: 
    wide_char_type
  | octet_type
  ;

template_type_spec:
     map_type
  ;

constr_type_dcl:
     bitset_dcl
   | bitmask_dcl
   ;

map_type:
    annotation_appls MAP '<' type_spec ',' type_spec ',' positive_int_const '>'
      { $$ = idl_new_map_type(context, $4, $6, $8); }
  | annotation_appls MAP '<' type_spec ',' type_spec '>'
      { $$ = idl_new_map_type_unbound(context, $4, $6); }
  ;

bitset_dcl:
    BITSET identifier scoped_name_opt 
      { idl_add_bitset_open(context, $2, $3); }
    '{' bitfields '}'
      { idl_bitset_close(context); }
  ;

scoped_name_opt:
    ':' scoped_name_opt { $$ = $2; }
  | { $$ = (idl_type_t*)0; }
  ;

bitfields:
    bitfield bitfields
  | bitfield
  ;

bitfield:
    bitfield_spec identifiers ';'
  ;

identifiers:
    identifier identifiers { idl_add_bitset_ident(context, $1); } 
  | identifier { idl_add_bitset_ident(context, $1); }
  ;

bitfield_spec:
    BITFIELD '<' positive_int_const '>'
      { idl_add_bitset_field(context, $3); }
  | BITFIELD '<' positive_int_const ',' destination_type '>'
      { idl_add_bitset_field_to(context, $3, $5); }
  ;

destination_type:
    boolean_type 
  | octet_type 
  | integer_type
  ;

bitmask_dcl:
    BITMASK identifier '{' bit_value_list '}'
      { idl_add_bitmask(context, $2, $4); }
  ;

bit_value_list:
    bit_value ',' bit_value_list { $$ = idl_new_bit_value_list(context, $1, $3); }
  | bit_value { $$ = idl_new_bit_value_list(context, $1, 0); }
  ;

bit_value: identifier ;

signed_int: 
    signed_tiny_int 
  | signed_short_int
  | signed_long_int
  | signed_longlong_int
  ;

unsigned_int:
    unsigned_tiny_int
  | unsigned_short_int
  | unsigned_long_int
  | unsigned_longlong_int
  ;

signed_tiny_int: INT8 { $$ = idl_int8; };
unsigned_tiny_int: UINT8 { $$ = idl_uint8; };
signed_short_int: INT16 { $$ = idl_short; };
signed_long_int: INT32 { $$ = idl_long; };
signed_longlong_int: INT64 { $$ = idl_longlong; };
unsigned_short_int: UINT16 { $$ = idl_ushort; };
unsigned_long_int: UINT32 { $$ = idl_ulong; };
unsigned_longlong_int: UINT64 { $$ = idl_ulonglong; };

// From Building Block Anonymous Types:
type_spec: template_type_spec ;
declarator: array_declarator ;

// From Building Block Annotations:
definition: annotation_dcl ';' ;

annotation_dcl:
    annotation_header '{' annotation_bodys '}'
      { idl_annotation_close(context); }
  ;
annotation_header:
    ANNOTATION identifier
      { idl_add_annotation_open(context, $2); }
  ;

annotation_bodys:
    annotation_body annotation_bodys
  |
  ;

annotation_body:
    annotation_member
  | enum_dcl ';'
  | const_dcl ';'
  | typedef_dcl ';'
  ;

annotation_member:
    annotation_member_type simple_declarator
      { idl_add_annotation_member_open(context, $1, $2); }
    default_opt ';'
      { idl_annotation_member_close(context); }
  ;
default_opt:
    DEFAULT const_expr ';'
      { idl_annotation_member_set_default(context, $2); }
  |
  ;

annotation_member_type:
    const_type 
  | any_const_type 
/*  | scoped_name -- included in const_type */ 
  ;

any_const_type: ANY { $$ = idl_any; };

annotation_appls:
    annotation_appl annotation_appls
  |
  ;

annotation_appl: 
    '@' scoped_name
      { idl_add_annotation_appl_open(context, $2); }
    annotation_appl_params_opt
      { idl_annotation_appl_close(context); }
  ;
annotation_appl_params_opt:
    '(' annotation_appl_params ')'
  |
  ;

annotation_appl_params:
    const_expr
      { idl_add_annotation_appl_expr(context, $1); }
  | annotation_appl_param_list
  ;

annotation_appl_param_list:
    annotation_appl_param ',' annotation_appl_param_list
  | annotation_appl_param
  ;

annotation_appl_param:
    identifier '=' const_expr
      { idl_add_annotation_appl_param(context, $1, $3); }
  ;

identifier:
    IDENTIFIER
      {
        size_t offset = 0;
        if ($1[0] == '_') {
          offset = 1;
        } else if (idl_parser_token_matches_keyword($1) != 0) {
          /* FIXME: come up with a better error message */
          yyerror(&yylloc, scanner, context, "Identifier matches a keyword");
          YYABORT;
        } else if (($$ = strdup($1 + offset)) == NULL) {
          /* FIXME: come up with a better error message */
          yyerror(&yylloc, scanner, context, "Memory exhausted");
          YYABORT;
        }
      };

/* Backward compatability #pragma keylist */

pragma_keylist:
    "#pragma" "keylist" identifier keylist_members ;
keylist_members:
    identifier keylist_members
  |
  ;

%%

int
yyerror(
  YYLTYPE *yylloc, yyscan_t yyscanner, idl_context_t *context, char *text)
{
  /* FIXME: implement */
  if (context != 0 && context->ignore_yyerror != 0) {
    return 0;
  }

  fprintf(stderr, "ERROR: %s\n", text);
  return 0;
}

static int
idl_parser_token_matches_keyword(const char *token)
{
  size_t i, n;

  assert(token != NULL);

  for (i = 0, n = strlen(token); i < YYNTOKENS; i++) {
    if (yytname[i] != 0
        && yytname[i][    0] == '"'
        //&& os_strncasecmp_c(yytname[i] + 1, token, n) == 0
        && strncmp(yytname[i]+1, token, n) == 0
        && yytname[i][n + 1] == '"'
        && yytname[i][n + 2] == 0)
    {
      return 1;
    }
  }

  return 0;
}

