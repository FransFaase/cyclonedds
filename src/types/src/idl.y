/*
 * Copyright(c) 2006 to 2018 ADLINK Technology Limited and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
 * v. 1.0 which is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 */
%{
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

/* yyscan_t is an opaque pointer, a typedef is required here to break a
   circular dependency introduced with bison 2.6 (normally a typedef is
   generated by flex). the define is required to disable the typedef in flex
   generated code */
#define YY_TYPEDEF_YY_SCANNER_T

typedef void *yyscan_t;

#include "idl.parser.h"
#include "yy_decl.h" /* prevent implicit declaration of yylex */

#define YYFPRINTF (unsigned int)fprintf

#define YYPRINT(A,B,C) YYUSE(A) /* to make yytoknum available */

int
yyerror(
  YYLTYPE *yylloc, yyscan_t yyscanner, dds_ts_context_t *context, char *text);

int illegale_identifier(const char *token);

%}

/* There is one shift/reduce conflict, which has not yet been resolved:
 * When an annotation application occurs before a scoped name, the grammar
 * should force no spaces in the scoped name of the annotation.
 */
%expect 1

%code requires {

#include "dds_tt.h"
#include "tt_create.h"
#include "os/os.h"

}


%union {
  bool boolean;
  dds_ts_node_flags_t base_type_flags;
  dds_ts_type_spec_t *type_spec;
  dds_ts_literal_t literal;
  dds_ts_identifier_t identifier;
  dds_ts_operator_type_t operator_type;
  dds_ts_scoped_name_t* scoped_name;
}

%define api.pure full
%define api.prefix {dds_ts_parser_}
%define parse.trace

%locations
%param {yyscan_t scanner}
%param {dds_ts_context_t *context}

%token-table

%start specification

%token <identifier>
  IDENTIFIER

%token <boolean>
  BOOLEAN_LITERAL

%token <literal>
  CHARACTER_LITERAL
  WIDE_CHARACTER_LITERAL
  STRING_LITERAL
  WIDE_STRING_LITERAL
  INTEGER_LITERAL
  FLOATING_PT_LITERAL
  FIXED_PT_LITERAL

%type <base_type_flags>
  simple_type_spec
  switch_type_spec
  base_type_spec
  destination_type
  floating_pt_type
  fixed_pt_const_type
  integer_type
  signed_int
  signed_tiny_int
  signed_short_int
  signed_long_int
  signed_longlong_int
  unsigned_int
  unsigned_tiny_int
  unsigned_short_int
  unsigned_long_int
  unsigned_longlong_int
  char_type
  wide_char_type
  boolean_type
  octet_type
  any_const_type

%type <type_spec>
  type_spec
  template_type_spec
  sequence_type
  string_type
  wide_string_type
  fixed_pt_type
  map_type
  const_type
  scoped_name_opt
  annotation_member_type

%type <scoped_name>
  scoped_name

%type <literal>
  positive_int_const
  literal
  const_expr
  or_expr
  xor_expr
  and_expr
  shift_expr
  add_expr
  mult_expr
  unary_expr
  primary_expr

%type <operator_type> unary_operator

%type <identifier>
  simple_declarator
  bit_value
  identifier

/* operators */
%token LSHIFT "<<"
%token RSHIFT ">>"

/* keywords */
%token DDS_MODULE "module"
%token DDS_CONST "const"
%token DDS_NATIVE "native"
%token DDS_STRUCT "struct"
%token DDS_TYPEDEF "typedef"
%token DDS_UNION "union"
%token DDS_SWITCH "switch"
%token DDS_CASE "case"
%token DDS_DEFAULT "default"
%token DDS_ENUM "enum"
%token DDS_UNSIGNED "unsigned"
%token DDS_FIXED "fixed"
%token DDS_SEQUENCE "sequence"
%token DDS_STRING "string"
%token DDS_WSTRING "wstring"

%token DDS_FLOAT "float"
%token DDS_DOUBLE "double"
%token DDS_SHORT "short"
%token DDS_LONG "long"
%token DDS_CHAR "char"
%token DDS_WCHAR "wchar"
%token DDS_BOOLEAN "boolean"
%token DDS_OCTET "octet"
%token DDS_ANY "any"

%token DDS_MAP "map"
%token DDS_BITSET "bitset"
%token DDS_BITFIELD "bitfield"
%token DDS_BITMASK "bitmask"

%token DDS_INT8 "int8"
%token DDS_UINT8 "uint8"
%token DDS_INT16 "int16"
%token DDS_INT32 "int32"
%token DDS_INT64 "int64"
%token DDS_UINT16 "uint16"
%token DDS_UINT32 "uint32"
%token DDS_UINT64 "uint64"

%token ANNOTATION "@annotation"


%%


/* Constant Declaration */

specification:
    definitions
  ;

definitions:
    definition definitions
  | definition
  ;

definition:
    module_dcl ';'
  | const_dcl ';'
  | type_dcl ';'
  | pragma_keylist
  ;

module_dcl:
    annotation_appls "module" identifier
       { dds_ts_module_open(context, $3); }
    '{' definitions '}'
       { dds_ts_module_close(context); };

scoped_name:
    identifier
      { $$ = dds_ts_new_scoped_name(context, 0, false, $1); }
  | "::" identifier
      { $$ = dds_ts_new_scoped_name(context, 0, true, $2); }
  | scoped_name "::" identifier
      { $$ = dds_ts_new_scoped_name(context, $1, false, $3); }
  ;

const_dcl:
    annotation_appls "const" const_type identifier '=' const_expr
      { dds_ts_add_const_def(context, $3, $4, &($6)); }
  ;

const_type:
    integer_type        { $$ = dds_ts_new_base_type(context, $1); }
  | floating_pt_type    { $$ = dds_ts_new_base_type(context, $1); }
  | fixed_pt_const_type { $$ = dds_ts_new_base_type(context, $1); }
  | char_type           { $$ = dds_ts_new_base_type(context, $1); }
  | wide_char_type      { $$ = dds_ts_new_base_type(context, $1); }
  | boolean_type        { $$ = dds_ts_new_base_type(context, $1); }
  | octet_type          { $$ = dds_ts_new_base_type(context, $1); }
  | string_type
  | wide_string_type
  | scoped_name { /*$$ = new_dds_ts_type_from_scoped_name($1);*/ }
  ;

const_expr:
    or_expr ;

or_expr:
    xor_expr
  | or_expr '|' xor_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_or, &($1), &($3), &($$)); };

xor_expr:
    and_expr
  | xor_expr '^' and_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_xor, &($1), &($3), &($$)); };

and_expr:
    shift_expr
  | and_expr '&' shift_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_and, &($1), &($3), &($$)); };

shift_expr:
    add_expr
  | shift_expr "<<" add_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_shift_left, &($1), &($3), &($$)); }
  | shift_expr ">>" add_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_shift_right, &($1), &($3), &($$)); };

add_expr:
    mult_expr
  | add_expr '+' mult_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_add, &($1), &($3), &($$)); }
  | add_expr '-' mult_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_sub, &($1), &($3), &($$)); };

mult_expr:
    unary_expr
  | mult_expr '*' unary_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_times, &($1), &($3), &($$)); }
  | mult_expr '/' unary_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_div, &($1), &($3), &($$)); }
  | mult_expr '%' unary_expr
      { dds_ts_eval_binary_oper(dds_ts_operator_mod, &($1), &($3), &($$)); };

unary_expr:
    unary_operator primary_expr { dds_ts_eval_unary_oper($1, &($2), &($$)); }
  | primary_expr;

unary_operator:
    '-' { $$ = dds_ts_operator_minus; }
  | '+' { $$ = dds_ts_operator_plus; }
  | '~' { $$ = dds_ts_operator_inv; };

primary_expr:
    scoped_name
      { dds_ts_get_value_of_scoped_name(context, $1, &($$)); }
  | literal
  | '(' const_expr ')'
      { $$ = $2; };

literal:
    INTEGER_LITERAL
  | FLOATING_PT_LITERAL
  | FIXED_PT_LITERAL
  | CHARACTER_LITERAL
  | WIDE_CHARACTER_LITERAL
  | BOOLEAN_LITERAL
      {
        dds_ts_literal_t* value = &($$);
        value->flags = DDS_TS_BOOLEAN_TYPE;
        value->bln = ($1);
      }
  | STRING_LITERAL
  | WIDE_STRING_LITERAL
  ;

positive_int_const:
    const_expr;

type_dcl:
    constr_type_dcl
  | native_dcl
  | typedef_dcl
  ;

type_spec:
    simple_type_spec { $$ = dds_ts_new_base_type(context, $1); };

simple_type_spec:
    base_type_spec
  | scoped_name { /*$$ = dds_ts_get_type_from_scoped_name($1);*/ }
  ;

base_type_spec:
    integer_type
  | floating_pt_type
  | char_type
  | wide_char_type
  | boolean_type
  | octet_type
  ;

/* Basic Types */
floating_pt_type:
    "float" { $$ = DDS_TS_FLOAT_TYPE; }
  | "double" { $$ = DDS_TS_DOUBLE_TYPE; }
  | "long" "double" { $$ = DDS_TS_LONG_DOUBLE_TYPE; };

integer_type:
    signed_int
  | unsigned_int
  ;

signed_int:
    "short" { $$ = DDS_TS_SHORT_TYPE; }
  | "long" { $$ = DDS_TS_LONG_TYPE; }
  | "long" "long" { $$ = DDS_TS_LONG_LONG_TYPE; }
  ;

unsigned_int:
    "unsigned" "short" { $$ = DDS_TS_UNSIGNED_SHORT_TYPE; }
  | "unsigned" "long" { $$ = DDS_TS_UNSIGNED_LONG_TYPE; }
  | "unsigned" "long" "long" { $$ = DDS_TS_UNSIGNED_LONG_LONG_TYPE; }
  ;

char_type:
    "char" { $$ = DDS_TS_CHAR_TYPE; };

wide_char_type:
    "wchar" { $$ = DDS_TS_WIDE_CHAR_TYPE; };

boolean_type:
    "boolean" { $$ = DDS_TS_BOOLEAN_TYPE; };

octet_type:
    "octet" { $$ = DDS_TS_OCTET_TYPE; };

template_type_spec:
    sequence_type
  | string_type
  | wide_string_type
  | fixed_pt_type
  ;

sequence_type:
    "sequence" '<' type_spec ',' positive_int_const '>'
      { $$ = dds_ts_new_sequence_type(context, $3, &($5)); }
  | "sequence" '<' type_spec '>'
      { $$ = dds_ts_new_sequence_type_unbound(context, $3); }
  ;

string_type:
    "string" '<' positive_int_const '>'
      { $$ = dds_ts_new_string_type(context, &($3)); }
  | "string"
      { $$ = dds_ts_new_string_type_unbound(context); }
  ;

wide_string_type:
    "wstring" '<' positive_int_const '>'
      { $$ = dds_ts_new_wide_string_type(context, &($3)); }
  | "wstring"
      { $$ = dds_ts_new_wide_string_type_unbound(context); }
  ;

fixed_pt_type:
    "fixed" '<' positive_int_const ',' positive_int_const '>'
      { $$ = dds_ts_new_fixed_type(context, &($3), &($5)); }
  ;

fixed_pt_const_type: "fixed" { $$ = DDS_TS_FIXED_PT_CONST_TYPE; };

constr_type_dcl:
    struct_dcl
  | union_dcl
  | enum_dcl
  ;

struct_dcl:
    struct_def
  | struct_forward_dcl
  ;

struct_def:
    annotation_appls "struct" identifier '{'
      { dds_ts_add_struct_open(context, $3); }
    members '}'
      { dds_ts_struct_close(context); }
  ;
members:
    member members
  | member
  ;

member:
    annotation_appls type_spec { dds_ts_add_struct_member(context, $2); }
    declarators ';'
  ;

struct_forward_dcl:
    annotation_appls "struct" identifier
      { dds_ts_add_struct_forward(context, $3); };

union_dcl:
    union_def
  | union_forward_dcl
  ;

union_def:
    annotation_appls "union" identifier "switch" '(' switch_type_spec ')'
       { dds_ts_add_union_open(context, $3, $6); }
    '{' switch_body '}'
       { dds_ts_union_close(context); }
  ;
switch_type_spec:
    integer_type
  | char_type
  | boolean_type
  | scoped_name { $$ = dds_ts_get_base_type_of_scoped_name(context, $1); }
  ;

switch_body: cases ;
cases:
    case cases
  | case
  ;

case:
    annotation_appls case_labels element_spec ';'
  ;

case_labels:
    case_label case_labels
  | case_label
  ;

case_label:
    "case" const_expr ':' { dds_ts_add_union_case_label(context, &($2)); }
  | "default" ':' { dds_ts_add_union_case_default(context); }
  ;

element_spec:
    type_spec declarator { dds_ts_add_union_element(context, $1); }
  ;

union_forward_dcl:
    annotation_appls "union" identifier { dds_ts_add_union_forward(context, $3); }
  ;


enum_dcl:
    annotation_appls "enum" identifier { dds_ts_add_enum_open(context, $3); }
    '{' enumerator_list '}' { dds_ts_enum_close(context); }
  ;

enumerator_list:
    enumerator ',' enumerator_list
  | enumerator
  ;

enumerator: annotation_appls identifier { dds_ts_add_enum_enumerator(context, $2); };

array_declarator:
    identifier
    fixed_array_sizes { dds_ts_add_declarator(context, $1); }
  ;

fixed_array_sizes:
    fixed_array_size fixed_array_sizes
  | fixed_array_size
  ;

fixed_array_size:
    '[' positive_int_const ']' { dds_ts_add_array_size(context, &($2)); }
  ;

native_dcl:
    annotation_appls "native" simple_declarator
      { dds_ts_add_native(context, $3); }
  ;

simple_declarator: identifier ;

typedef_dcl:
    annotation_appls "typedef" { dds_ts_add_typedef_open(context); }
    type_declarator
  ;

type_declarator:
    simple_type_spec
      { dds_ts_typedef_set_type(context, dds_ts_new_base_type(context, $1)); }
    any_declarators
      { dds_ts_typedef_close(context); }
  | template_type_spec
      { dds_ts_typedef_set_type(context, $1); }
    any_declarators
      { dds_ts_typedef_close(context); }
  | constr_type_dcl any_declarators
      { dds_ts_typedef_close(context); }
  ;

any_declarators:
    any_declarator ',' any_declarators
  | any_declarator
  ;

any_declarator:
    simple_declarator
  | array_declarator
  ;

declarators:
    declarator ',' declarators
  | declarator
  ;

declarator: simple_declarator
      { dds_ts_add_declarator(context, $1); };


/* From Building Block Extended Data-Types: */
struct_def:
    annotation_appls "struct" identifier ':' scoped_name '{'
      { dds_ts_add_struct_extension_open(context, $3, $5); }
    members '}'
      { dds_ts_struct_close(context); }
  | annotation_appls "struct" identifier '{'
      { dds_ts_add_struct_open(context, $3); }
    '}'
      { dds_ts_struct_empty_close(context); }
  ;

switch_type_spec:
    wide_char_type
  | octet_type
  ;

template_type_spec:
     map_type
  ;

constr_type_dcl:
     bitset_dcl
   | bitmask_dcl
   ;

map_type:
    "map" '<' type_spec ',' type_spec ',' positive_int_const '>'
      { $$ = dds_ts_new_map_type(context, $3, $5, &($7)); }
  | "map" '<' type_spec ',' type_spec '>'
      { $$ = dds_ts_new_map_type_unbound(context, $3, $5); }
  ;

bitset_dcl:
    "bitset" identifier scoped_name_opt
      { dds_ts_add_bitset_open(context, $2, $3); }
    '{' bitfields '}'
      { dds_ts_bitset_close(context); }
  ;

scoped_name_opt:
    ':' scoped_name_opt { $$ = $2; }
  | { $$ = (dds_ts_type_spec_t*)0; }
  ;

bitfields:
    bitfield bitfields
  | bitfield
  ;

bitfield:
    bitfield_spec identifiers ';'
  ;

identifiers:
    identifier identifiers { dds_ts_add_bitset_ident(context, $1); }
  | identifier { dds_ts_add_bitset_ident(context, $1); }
  ;

bitfield_spec:
    "bitfield" '<' positive_int_const '>'
      { dds_ts_add_bitset_field(context, &($3)); }
  | "bitfield" '<' positive_int_const ',' destination_type '>'
      { dds_ts_add_bitset_field_to(context, &($3), $5); }
  ;

destination_type:
    boolean_type
  | octet_type
  | integer_type
  ;

bitmask_dcl:
    "bitmask" identifier '{'
      { dds_ts_add_bitmask_open(context, $2); }
    bit_value_list '}'
      { dds_ts_bitmask_close(context); }
  ;

bit_value_list:
    bit_value ',' bit_value_list
  | bit_value { dds_ts_add_bitmask_value(context, $1); }
  ;

bit_value: identifier ;

signed_int:
    signed_tiny_int
  | signed_short_int
  | signed_long_int
  | signed_longlong_int
  ;

unsigned_int:
    unsigned_tiny_int
  | unsigned_short_int
  | unsigned_long_int
  | unsigned_longlong_int
  ;

signed_tiny_int: "int8" { $$ = DDS_TS_INT8_TYPE; };
unsigned_tiny_int: "uint8" { $$ = DDS_TS_UINT8_TYPE; };
signed_short_int: "int16" { $$ = DDS_TS_SHORT_TYPE; };
signed_long_int: "int32" { $$ = DDS_TS_LONG_TYPE; };
signed_longlong_int: "int64" { $$ = DDS_TS_LONG_LONG_TYPE; };
unsigned_short_int: "uint16" { $$ = DDS_TS_UNSIGNED_SHORT_TYPE; };
unsigned_long_int: "uint32" { $$ = DDS_TS_UNSIGNED_LONG_TYPE; };
unsigned_longlong_int: "uint64" { $$ = DDS_TS_UNSIGNED_LONG_LONG_TYPE; };

/* From Building Block Anonymous Types: */
type_spec: template_type_spec ;
declarator: array_declarator ;

/* From Building Block Annotations: */
definition: annotation_dcl ';' ;

annotation_dcl:
    annotation_header '{' annotation_bodys '}'
      { dds_ts_annotation_close(context); }
  ;
annotation_header:
    ANNOTATION identifier
      { dds_ts_add_annotation_open(context, $2); }
  ;

annotation_bodys:
    annotation_body annotation_bodys
  |
  ;

annotation_body:
    annotation_member
  | enum_dcl ';'
  | const_dcl ';'
  | typedef_dcl ';'
  ;

annotation_member:
    annotation_member_type simple_declarator
      { dds_ts_add_annotation_member_open(context, $1, $2); }
    default_opt ';'
      { dds_ts_annotation_member_close(context); }
  ;
default_opt:
    "default" const_expr ';'
      { dds_ts_annotation_member_set_default(context, &($2)); }
  |
  ;

annotation_member_type:
    const_type
  | any_const_type { $$ = dds_ts_new_base_type(context, $1); }
/*  | scoped_name -- included in const_type */
  ;

any_const_type: "any" { $$ = DDS_TS_ANY_TYPE; };

annotation_appls:
    annotation_appl annotation_appls
  |
  ;

annotation_appl:
    '@' scoped_name
      { dds_ts_add_annotation_appl_open(context, $2); }
    annotation_appl_params_opt
      { dds_ts_annotation_appl_close(context); }
  ;
annotation_appl_params_opt:
    '(' annotation_appl_params ')'
  |
  ;

annotation_appl_params:
    const_expr
      { dds_ts_add_annotation_appl_expr(context, &($1)); }
  | annotation_appl_param_list
  ;

annotation_appl_param_list:
    annotation_appl_param ',' annotation_appl_param_list
  | annotation_appl_param
  ;

annotation_appl_param:
    identifier '=' const_expr
      { dds_ts_add_annotation_appl_param(context, $1, &($3)); }
  ;

identifier:
    IDENTIFIER
      {
        size_t offset = 0;
        if ($1[0] == '_') {
          offset = 1;
        } else if (illegale_identifier($1) != 0) {
          yyerror(&yylloc, scanner, context, "Identifier matches a keyword");
          YYABORT;
        }
        if (($$ = strdup($1 + offset)) == NULL) {
          YYABORT;
        }
      };

/* Backward compatability #pragma keylist */

pragma_keylist:
    "#pragma" "keylist" identifier keylist_members ;
keylist_members:
    identifier keylist_members
  |
  ;

%%

int
yyerror(
  YYLTYPE *yylloc, yyscan_t yyscanner, dds_ts_context_t *context, char *text)
{
  (void)yyscanner;
  /* FIXME: implement */
  if (dds_ts_context_get_ignore_yyerror(context)) {
    return 0;
  }

  fprintf(stderr, "ERROR: %d.%d %s\n", yylloc->first_line, yylloc->first_column, text);
  return 0;
}

int
illegale_identifier(const char *token)
{
  size_t i, n;

  assert(token != NULL);

  for (i = 0, n = strlen(token); i < YYNTOKENS; i++) {
    if (yytname[i] != 0
        && yytname[i][    0] == '"'
        && os_strncasecmp(yytname[i] + 1, token, n) == 0
        && yytname[i][n + 1] == '"'
        && yytname[i][n + 2] == '\0')
    {
      return 1;
    }
  }

  return 0;
}

int
parser_token_matches_keyword(const char *token, int *token_number)
{
  size_t i, n;

  assert(token != NULL);
  assert(token_number != NULL);

  for (i = 0, n = strlen(token); i < YYNTOKENS; i++) {
    if (yytname[i] != 0
        && yytname[i][    0] == '"'
        && strncmp(yytname[i] + 1, token, n) == 0
        && yytname[i][n + 1] == '"'
        && yytname[i][n + 2] == 0)
    {
      *token_number = yytoknum[i];
      return 1;
    }
  }

  return 0;
}

