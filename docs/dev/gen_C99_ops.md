# Generating C99 source file: ops structure

As part of the C99 source file, there is an array of uint32\_t specifying the
operation codes for (de)marshalling the data from and to the data structures
defined in the generated header file.

This sequence is generated by starting with the struct and output some
operation codes for each of the members of the struct, followed by a return
operation code.

For members with a basic type, at least two uint32\_t values are used. The
first specifies the operation and the second and following the operands.
The operation is specified by combining (with bit-or) flags. The flags
specify:
* The type of the member. For the basic type this specifies the size of
  the type. For string and bounded string, separate flags are used.
* Whether the field is a key field
* Whether it is an array. If it is an extra operand will speficify the
  total size of the array (by multiplying the sizes of the various dimensions).
* Whether the type is a sequence. (In case the elment type is a struct,
  additional information will follow the operation and its operands,
  as described below.)
In case of a bounded string, an extra operand will follow, to specify the
size (including its terminating null-character) of the bounded string.

When a member is a struct (both embedded and refered), the members of that
struct are also included. When a member is a sequence to struct, the
description of the struct followes the the operation code for a struct.
The description starts with an opening operation (specifying the size of
the struct) followed by the operation codes for the members and closed
with a return operation code.

The current implementation does not support recursive types. With a recursive
type it is not possible to follow the above procedure. Instead of generating
the description on the struct (and its members), a jump subroutine operation
code can be used, which jumps to an earlier (or later) description of the
structure. There are two methods for deciding when to use a jump subroutine
operation:
1. Whenever a recursion is detected.
2. Whenever a description of a struct already has been generated.
The second method could lead to less operations, where the first method could
lead to slightly efficient execution. In practice, the probably won't make
much difference. The second method is slightly easier to implement: simple
maintain a map of structures to offsets (of the start of a struct description
from the start of the sequence).

## Adapting current API

The current API only traverses the embedded structs, not the referenced ones.
Also the structs of sequences are not traversed. For inlined members the
member names need to be concatenated (with a period). This means that when
following a reference struct, the call-back function needs information of
how it was called. In the current code, the parents of the tree are followed
to generate names for types. Maybe some generic method for providing the
context (path) for the call-back functions should be implemented, as there
might be more cases where a call-back function might need information about
how it was called.

From the idea that the traversal method determines which call-back functions
should be called, and the call-back functions perform the domain specific
functions (such as generating code). In case of recursive functions, the
traversal method can determine when (for both of the methods) to call the
call-back function for generating the jump subroutine. However, this
call-back function also needs to know the offset. The question is whether
the offsets (which are domain specific) should be managed by the traversal
method or by the call-back functions? There are several solutions to this
problem:
1. For now, let the traversal method store the value, similar to how it
   also does for how forward struct declarations and struct definitions
   are encountered during the traversal.
2. Instead of passing an integer type, Make use of a generic void pointer
   specific for the structs, which the domain specific methods can use to
   store arbitrary data into. (Probably, also need a call-back function
   for freeing the data structures, after the traversal has finished.)
3. Let the call-back functions maintain data structures in the void
   context pointer that they now already receive. The map of struct to offset
   can than be implemented here. (This implies some double administration.)

## Alternative to op-codes

Now that the type tree is stored, it is possible to base the (un)marshalling
code on the type tree directly. The sizes of structs and the offset of
members of the struct relative to the start of the struct, are still needed.
On could either determine a method (which might be compiler specific) to
determine the sizes of the members or in the source fill generate data
structures describiing those sizes and offsets, which then are passed to
the (un)marshalling code, or inserted into the type tree.

